#!/bin/bash

SRC_DIR=$(dirname $(realpath $0))/rootfs

[ ! -d "${SRC_DIR}/loopback" ] && mkdir "${SRC_DIR}/loopback"
[ ! -d "${SRC_DIR}/sgibootcd" ] && mkdir "${SRC_DIR}/sgibootcd"

# Setup variables
[ -f "${SRC_DIR}/livecd" ] && rm -f "${SRC_DIR}/livecd"
img="${SRC_DIR}/loopback/image.squashfs"
knl="${SRC_DIR}/kernels"
arc="${SRC_DIR}/arcload"
cfg="${SRC_DIR}/sgibootcd/sgibootcd.cfg"
echo "" > "${cfg}"

# If the image file exists in $clst_target_path, move it to the loopback dir
[ -e "${SRC_DIR}/image.squashfs" ] \
    && mv -f "${SRC_DIR}/image.squashfs" "${SRC_DIR}/loopback"

# An sgibootcd config is essentially a collection of commandline params
# stored in a text file.  We could pass these on the command line, but it's
# far easier to generate a config file and pass it to sgibootcd versus using a
# ton of commandline params.
#
# f=	indicates files to go into DVH (disk volume header) in an SGI disklabel
#	    format: f=</path/to/file>@<DVH name>
# p0=	the first partition holds the LiveCD livecd image
#	    format: p0=</path/to/image>
# p8=	the eighth partition is the DVH partition
# p10=	the tenth partition is the disk volume partition
#	    format: p8= is always "#dvh" and p10= is always "#volume"

# Add the kernels to the sgibootcd config
for x in ${clst_boot_kernel}; do
    echo -e "f=${knl}/${x}@${x}" >> ${cfg}
done

# Next, the bootloader binaries and config
echo -e "f=${arc}/sash64@sash64" >> ${cfg}
echo -e "f=${arc}/sashARCS@sashARCS" >> ${cfg}
echo -e "f=${arc}/arc.cf@arc.cf" >> ${cfg}

# Next, the Loopback Image
echo -e "p0=${img}" >> ${cfg}

# Finally, the required SGI Partitions (dvh, volume)
echo -e "p8=#dvh" >> ${cfg}
echo -e "p10=#volume" >> ${cfg}

# All done; feed the config to sgibootcd and end up with an image
# c=	the config file
# o=	output image (burnable to CD; readable by fdisk)
/usr/bin/sgibootcd c=${cfg} o=${clst_iso}